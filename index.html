<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LMS — Початок</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    body{ overflow:hidden; background:#000; color:#f3eed7; }

    #wrap{
      position:fixed; inset:0;
      background:
        radial-gradient(1200px 700px at 50% 45%,
          rgba(70,85,180,.22),
          rgba(10,10,18,.92) 60%,
          #000 100%);
    }
    canvas{ display:block; width:100%; height:100%; }

    #vignette{
      position:fixed; inset:-2px;
      background: radial-gradient(1200px 800px at 50% 50%, transparent 42%, rgba(0,0,0,.70) 100%);
      pointer-events:none;
      z-index:1;
      opacity:.88;
      transition: opacity 1.1s ease;
    }

    .intro{
      position:fixed; inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding:6vw;
      z-index:2;
      pointer-events:none;
      transition: opacity 1.0s ease, transform 1.0s ease;
    }

    .intro::before{
      content:"";
      position:absolute;
      width:min(980px,92vw);
      height:min(520px,60vh);
      border-radius:999px;
      background: radial-gradient(closest-side, rgba(0,0,0,.58), rgba(0,0,0,0));
      z-index:-1;
    }

    h1{
      margin:0 0 1.1rem;
      font-family:"Cormorant Garamond", serif;
      font-weight:500;
      font-size:clamp(3.2rem, 8.2vw, 7.1rem);
      line-height:.92;
      letter-spacing:-0.01em;
      color:rgba(243,238,215,.96);
      text-shadow: 0 24px 80px rgba(0,0,0,.55);
    }

    .subtitle{
      margin:0 0 2.5rem;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size:clamp(1.05rem,2.2vw,1.5rem);
      opacity:.86;
      line-height:1.55;
      max-width:820px;
    }

    #startBtn{
      pointer-events:auto;
      padding:1rem 3.5rem;
      font-size:.95rem;
      letter-spacing:.32em;
      text-transform:uppercase;
      background:transparent;
      border:1.5px solid rgba(243,238,215,.55);
      color:#f3eed7;
      cursor:pointer;
      transition:transform .35s ease, background .35s ease, border-color .35s ease;
    }
    #startBtn:hover{
      border-color: rgba(243,238,215,.92);
      background: rgba(243,238,215,.08);
      transform: translateY(-3px);
    }
    #startBtn:active{ transform: translateY(-1px) scale(.99); }

    #fade{
      position:fixed; inset:0;
      background:#000;
      opacity:0;
      transition: opacity 1.0s ease;
      pointer-events:none;
      z-index:4;
    }

    body.flying .intro{
      opacity:0;
      transform: translateY(-6px) scale(.99);
    }
    body.flying #vignette{ opacity: 1; }

    @media (max-width: 700px){
      h1{ font-size:clamp(2.6rem, 10vw, 4.6rem); }
      #startBtn{ padding:.95rem 2.8rem; }
    }
  </style>
</head>

<body>
  <div id="wrap"></div>
  <div id="vignette"></div>

  <div class="intro">
    <h1>Навчання — це подорож</h1>
    <p class="subtitle">Крізь час і знання</p>
    <button id="startBtn">ПОЧАТИ</button>
  </div>

  <div id="fade"></div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

    const wrap = document.getElementById("wrap");
    const btn  = document.getElementById("startBtn");
    const fade = document.getElementById("fade");

    // renderer
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    wrap.appendChild(renderer.domElement);

    // scene/camera
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 40, 420);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 900);
    camera.position.set(0, 0, 20);

    // texture for year
    function makeYearTexture(text){
      const c = document.createElement("canvas");
      c.width = 512;
      c.height = 256;
      const ctx = c.getContext("2d");
      ctx.clearRect(0,0,c.width,c.height);

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "88px 'Cormorant Garamond', serif";

      ctx.shadowColor = "rgba(243,238,215,0.85)";
      ctx.shadowBlur  = 28;
      ctx.fillStyle   = "rgba(243,238,215,0.70)";
      ctx.fillText(String(text), c.width/2, c.height/2);

      ctx.shadowBlur = 0;
      ctx.fillStyle  = "rgba(243,238,215,0.98)";
      ctx.fillText(String(text), c.width/2, c.height/2);

      const tex = new THREE.CanvasTexture(c);
      tex.needsUpdate = true;
      return tex;
    }

    const texCache = new Map();
    function getYearTex(y){
      const key = String(y);
      if (texCache.has(key)) return texCache.get(key);
      const t = makeYearTexture(key);
      texCache.set(key, t);
      return t;
    }

    const yearsGroup = new THREE.Group();
    scene.add(yearsGroup);

    const NOW = new Date().getFullYear();
    const MIN_YEAR = 1700;
    const MAX_YEAR = NOW + 40;

    function createYearSprite(y){
      const mat = new THREE.SpriteMaterial({
        map: getYearTex(y),
        transparent: true,
        opacity: 0.0,
        depthWrite: false
      });
      const s = new THREE.Sprite(mat);

      const z = -(30 + Math.random() * 360);
      const x = (Math.random() - 0.5) * 180;
      const yy = (Math.random() - 0.5) * 95;
      s.position.set(x, yy, z);

      const base = 5.0 + Math.random() * 10.0;
      s.scale.set(base * 2.2, base * 1.1, 1);

      s.userData = {
        baseX: x,
        baseY: yy,
        seed: Math.random() * Math.PI * 2,
        wobble: Math.random() * 1.8 + 0.8,
        baseOpacity: 0.0,
        blur: 0.0
      };

      yearsGroup.add(s);
      return s;
    }

    const YEAR_COUNT = 320;
    const sprites = [];
    for (let i=0; i<YEAR_COUNT; i++){
      const y = MIN_YEAR + Math.floor(Math.random() * (MAX_YEAR - MIN_YEAR + 1));
      sprites.push(createYearSprite(y));
    }

    // mouse
    let mx=0, my=0;
    window.addEventListener("mousemove", (e)=>{
      mx = (e.clientX / window.innerWidth  - 0.5);
      my = (e.clientY / window.innerHeight - 0.5);
    });

    // flight transition state
    let flying = false;
    let flightT = 0;              // 0..1
    const FLIGHT_DUR = 1200;       // ms

    // motion
    let zSpeed = 0.12;
    let camZ   = camera.position.z;
    let autoPhase = 0;

    function recycleSprite(s){
      const newZ = camZ - (260 + Math.random() * 220);
      const x = (Math.random() - 0.5) * 180;
      const y = (Math.random() - 0.5) * 95;
      s.position.set(x, y, newZ);

      const yval = MIN_YEAR + Math.floor(Math.random() * (MAX_YEAR - MIN_YEAR + 1));
      s.material.map = getYearTex(yval);
      s.material.needsUpdate = true;

      const base = 5.0 + Math.random() * 10.0;
      s.scale.set(base * 2.2, base * 1.1, 1);

      s.userData.baseX = x;
      s.userData.baseY = y;
      s.userData.seed = Math.random() * Math.PI * 2;
      s.userData.wobble = Math.random() * 1.8 + 0.8;
    }

    // easing
    const clamp01 = (v)=> Math.max(0, Math.min(1, v));
    const easeInOutCubic = (t)=> (t < 0.5) ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
    const easeOutCubic = (t)=> 1 - Math.pow(1 - t, 3);

    btn.addEventListener("click", ()=>{
      if (flying) return;
      flying = true;
      flightT = 0;
      document.body.classList.add("flying");
      btn.style.pointerEvents = "none";
    });

    let last = performance.now();
    function animate(now){
      const dt = Math.min(40, now - last);
      last = now;

      const tsec = now * 0.001;

      // auto drift + mouse
      autoPhase += 0.010;
      const autoX = Math.sin(autoPhase) * 7.0;
      const autoY = Math.cos(autoPhase * 0.85) * 4.2;

      // during flight we reduce side motion so it feels like "tunnel"
      const sideFactor = flying ? (1 - easeOutCubic(flightT)) : 1;
      const tx = (autoX + mx * 14.0) * sideFactor;
      const ty = (autoY - my * 9.0) * sideFactor;

      camera.position.x += (tx - camera.position.x) * 0.06;
      camera.position.y += (ty - camera.position.y) * 0.06;

      // speed / flight
      if (!flying){
        zSpeed += (0.12 - zSpeed) * 0.04;
      } else {
        // advance flight
        flightT = clamp01(flightT + dt / FLIGHT_DUR);
        const e = easeInOutCubic(flightT);

        // accelerate camera forward hard (the "dive")
        const targetSpeed = 0.12 + e * 2.65; // <- feel of acceleration
        zSpeed += (targetSpeed - zSpeed) * 0.12;

        // fade overlay in near the end
        if (flightT > 0.55){
          const f = (flightT - 0.55) / 0.45;
          fade.style.opacity = String(clamp01(f) * 1.0);
        }
      }

      camZ -= zSpeed;
      camera.position.z = camZ;

      camera.lookAt(
        camera.position.x * 0.08,
        camera.position.y * 0.08,
        camZ - 140
      );

      // update sprites
      for (const s of sprites){
        const dz = (s.position.z - camZ);

        if (dz > 16){
          recycleSprite(s);
          continue;
        }

        // subtle drift
        const wob = Math.sin(tsec * s.userData.wobble + s.userData.seed);
        const wobY = Math.cos(tsec * (s.userData.wobble*0.9) + s.userData.seed);

        s.position.x += (s.userData.baseX + wob * 1.8 - s.position.x) * 0.03;
        s.position.y += (s.userData.baseY + wobY * 1.2 - s.position.y) * 0.03;

        // depth: 0..1 (far..near)
        const depth = THREE.MathUtils.clamp((-dz) / 380, 0, 1);

        // base visibility (far visible, near strong)
        let opacity = 0.18 + Math.pow(depth, 1.2) * 0.72;

        // during flight: wipe years out + add "speed blur" feeling
        if (flying){
          const e = easeInOutCubic(flightT);
          opacity *= (1 - e * 0.92);
          const blur = e * 10.0;
          // SpriteMaterial doesn't support blur; we fake it by making them larger + dimmer
          const scaleBoost = 1 + e * 2.8;
          s.scale.set(s.scale.x * scaleBoost, s.scale.y * scaleBoost, 1);
          // slight stretch in Y to feel motion
          s.scale.y *= (1 + e * 0.55);
          // tiny jitter forward feel
          s.material.rotation = Math.sin(tsec*0.9 + s.userData.seed) * (0.02 + e*0.08);
        } else {
          s.material.rotation = Math.sin(tsec*0.16 + s.userData.seed) * 0.02;
        }

        s.material.opacity = opacity;
      }

      renderer.render(scene, camera);

      // end flight => go to main
      if (flying && flightT >= 1){
        location.href = "./main.html#overview";
        return;
      }

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    window.addEventListener("resize", ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>
</html>
