<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>LMS — Початок</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');

    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{
      background:#000;
      color:#f3eed7;
      overflow:hidden;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    /* сцена */
    #intro{
      position:fixed; inset:0;
      background:
        radial-gradient(1200px 700px at 50% 45%, rgba(70,85,180,.22), rgba(10,10,18,.92) 60%, #000 100%);
      overflow:hidden;
    }

    /* “камера”: perspective + 3D */
    #stage{
      position:absolute; inset:0;
      perspective:1400px;
      transform-style:preserve-3d;
    }

    /* контейнер для всіх дат (на нього вішаємо “камеру”) */
    #world{
      position:absolute; inset:0;
      transform-style:preserve-3d;
      will-change:transform;
    }

    /* дати */
    .year{
      position:absolute;
      left:50%; top:50%;
      transform-style:preserve-3d;
      will-change:transform, opacity, filter;

      font-family:'Cormorant Garamond', serif;
      font-weight:400;
      letter-spacing:-0.01em;
      color: rgba(243,238,215,.34);
      text-shadow: 0 0 14px rgba(243,238,215,.18);
      pointer-events:none;
      user-select:none;

      /* трішки “плівки” */
      filter: saturate(.95) contrast(1.03);
    }

    /* контент */
    .intro{
      position:absolute; inset:0;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      padding: 6vw;
      z-index:5;
      transition: opacity 1.2s ease;
    }

    h1{
      font-family:'Cormorant Garamond', serif;
      font-weight:500;
      font-size: clamp(3.2rem, 8vw, 7.2rem);
      line-height: .92;
      letter-spacing:-0.01em;
      margin:0 0 1.1rem;
      text-shadow: 0 24px 80px rgba(0,0,0,.55);
    }

    .subtitle{
      margin:0 0 2.6rem;
      font-size: clamp(1.05rem, 2.2vw, 1.5rem);
      opacity:.86;
      max-width: 820px;
      line-height:1.55;
    }

    #startBtn{
      padding: 1rem 3.5rem;
      font-size: .95rem;
      letter-spacing: .32em;
      text-transform: uppercase;
      background: transparent;
      border: 1.5px solid rgba(243,238,215,.55);
      color:#f3eed7;
      cursor:pointer;
      transition: transform .35s ease, background .35s ease, border-color .35s ease, opacity .35s ease;
    }
    #startBtn:hover{
      border-color: rgba(243,238,215,.92);
      background: rgba(243,238,215,.08);
      transform: translateY(-3px);
    }
    #startBtn:active{ transform: translateY(-1px) scale(.99); }

    /* fade + vignette */
    #fade{
      position:fixed; inset:0;
      background:#000;
      opacity:0;
      transition: opacity 1.35s ease;
      z-index:10;
      pointer-events:none;
    }

    /* при “зануренні” */
    body.flying .intro{ opacity:0; }
    body.flying #startBtn{ opacity:0; }

    /* м’яка віньєтка поверх */
    #vignette{
      position:absolute; inset:-2px;
      background:
        radial-gradient(1200px 800px at 50% 50%, transparent 40%, rgba(0,0,0,.65) 100%);
      pointer-events:none;
      z-index:4;
      mix-blend-mode: multiply;
      opacity:.8;
    }
  </style>
</head>

<body>
  <div id="intro">
    <div id="stage">
      <div id="world"></div>
    </div>

    <div id="vignette" aria-hidden="true"></div>

    <div class="intro">
      <h1>Навчання — це подорож</h1>
      <p class="subtitle">Крізь час і знання</p>
      <button id="startBtn">ПОЧАТИ</button>
    </div>
  </div>

  <div id="fade"></div>

  <script>
    const world = document.getElementById('world');
    const btn   = document.getElementById('startBtn');
    const fade  = document.getElementById('fade');

    // === параметри “як у 100lostspecies”-стилі (3D поле + камера) ===
    const CFG = {
      count: 120,            // кількість дат
      minYear: 1700,
      maxYear: new Date().getFullYear() + 40,

      // розмір “об’єму”
      radiusMin: 520,
      radiusMax: 1500,
      zMin: -1400,
      zMax:  1200,

      // safe-zone (щоб не перекривати заголовок/кнопку)
      safeRX: 520,           // ширина еліпса в центрі
      safeRY: 260,           // висота еліпса в центрі

      // рух/дрейф
      drift: 0.55,           // сила мікродрейфу
      spring: 0.018,         // повернення до базової позиції (щоб “не летіло вбік”)

      // паралакс від миші
      parallaxXY: 42,
      rotX: 7,
      rotY: 10,

      // “занурення”
      flyZ: 2600,
      flyDuration: 1650
    };

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp = (a,b,t)=>a+(b-a)*t;
    const rand = (a,b)=>a+Math.random()*(b-a);

    // easing близький до “cinematic”
    function easeInOutCubic(t){
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
    }

    // позиція миші
    let mx = 0, my = 0;
    window.addEventListener('mousemove', (e)=>{
      mx = (e.clientX / innerWidth  - 0.5);
      my = (e.clientY / innerHeight - 0.5);
    });

    // респонс на resize (нічого важкого — тільки перерендер)
    let W = innerWidth, H = innerHeight;
    window.addEventListener('resize', ()=>{
      W = innerWidth; H = innerHeight;
    });

    // === Генерація “хмари” дат навколо центру, але з вирізом safe-zone ===
    const nodes = [];

    function inSafeZone(x,y){
      // еліпс у центрі
      const nx = x / CFG.safeRX;
      const ny = y / CFG.safeRY;
      return (nx*nx + ny*ny) < 1;
    }

    function makeNode(i){
      const el = document.createElement('div');
      el.className = 'year';

      const year = Math.floor(rand(CFG.minYear, CFG.maxYear+1));
      el.textContent = year;

      // розмір залежить від “глибини” (z): ближче — більші
      // реальний розмір буде ще підкручуватись під час анімації
      world.appendChild(el);

      // Розкидуємо точки в “кільці” навколо центру, уникаючи safe-zone
      let x,y,z;
      let tries = 0;
      do{
        const a = rand(0, Math.PI*2);
        const r = rand(CFG.radiusMin, CFG.radiusMax);
        x = Math.cos(a)*r + rand(-180,180);
        y = Math.sin(a)*r*0.62 + rand(-260,260);
        z = rand(CFG.zMin, CFG.zMax);
        tries++;
        // якщо дуже застрягли — послабимо safe-zone
        if(tries > 80) break;
      }while(inSafeZone(x,y));

      const baseOpacity = rand(0.16, 0.42);
      const seed = rand(0, 1000);

      const node = {
        el,
        // базова позиція
        x0:x, y0:y, z0:z,
        // поточна (анімаційна)
        x:x, y:y, z:z,
        // дрейф (без системного зсуву)
        vx: rand(-1,1),
        vy: rand(-1,1),
        vz: rand(-1,1),
        baseOpacity,
        seed
      };

      nodes.push(node);
      return node;
    }

    for(let i=0;i<CFG.count;i++) makeNode(i);

    // === Стан “занурення” ===
    let flying = false;
    let flyStart = 0;

    // “камера” — transform на #world
    let camZ = 0;      // вперед/назад
    let camRX = 0;     // rotateX
    let camRY = 0;     // rotateY
    let camX = 0;      // translateX
    let camY = 0;      // translateY

    function renderNode(n, tNorm, flyingEase){
      // tNorm — час у секундах (для синусів)
      // flyingEase — 0..1 при зануренні

      // дрейф, але без “відльоту”:
      // 1) додаємо легкий шум
      // 2) пружиною тягнемо назад до x0/y0/z0
      const wob = CFG.drift;

      const nx = Math.sin((tNorm*0.9) + n.seed) * wob;
      const ny = Math.cos((tNorm*0.8) + n.seed*1.3) * wob;
      const nz = Math.sin((tNorm*0.7) + n.seed*0.7) * (wob*0.55);

      n.x += (nx + (n.x0 - n.x) * CFG.spring);
      n.y += (ny + (n.y0 - n.y) * CFG.spring);
      n.z += (nz + (n.z0 - n.z) * CFG.spring);

      // “depth” для розміру/опациті
      // map z: ближче (більше) -> крупніше/яскравіше
      const z = n.z;
      const depth = (z - CFG.zMin) / (CFG.zMax - CFG.zMin); // 0..1
      const size = lerp(18, 56, depth);                     // px
      const op = clamp(n.baseOpacity + depth*0.10, 0.08, 0.55);

      // під час занурення: легкий blur + згасання
      const blur = flyingEase * 14;
      const op2  = op * (1 - flyingEase*1.15);

      // додатковий “push” вперед при зануренні — імітує проліт крізь поле
      const flyPush = flyingEase * 2400;

      n.el.style.fontSize = `${size}px`;
      n.el.style.opacity = `${Math.max(0, op2)}`;
      n.el.style.filter = `blur(${blur}px)`;

      // позиція в 3D відносно центру (left/top 50%)
      n.el.style.transform = `translate3d(${n.x}px, ${n.y}px, ${n.z + flyPush}px)`;
    }

    function tick(ts){
      const t = ts * 0.001;

      // миша -> камера (паралакс + ротація)
      // робимо інерцію, щоб було “плавно як на референсі”
      const targetX  = mx * CFG.parallaxXY;
      const targetY  = my * CFG.parallaxXY;
      const targetRX = (-my) * CFG.rotX;
      const targetRY = ( mx) * CFG.rotY;

      camX  = lerp(camX,  targetX,  0.08);
      camY  = lerp(camY,  targetY,  0.08);
      camRX = lerp(camRX, targetRX, 0.07);
      camRY = lerp(camRY, targetRY, 0.07);

      let flyingEase = 0;

      if(flying){
        const dt = (ts - flyStart) / CFG.flyDuration;
        const tt = clamp(dt, 0, 1);
        flyingEase = easeInOutCubic(tt);

        // камера летить ВПЕРЕД (по Z)
        camZ = lerp(0, CFG.flyZ, flyingEase);

        // у фіналі — редірект
        if(tt >= 1){
          location.href = './main.html#overview';
          return;
        }
      } else {
        camZ = lerp(camZ, 0, 0.06);
      }

      // apply camera transform (важливо: translateZ йде останнім, щоб було “занурення”)
      world.style.transform =
        `translate3d(${camX}px, ${camY}px, ${-camZ}px) rotateX(${camRX}deg) rotateY(${camRY}deg)`;

      // рендеримо всі дати
      for(const n of nodes) renderNode(n, t, flyingEase);

      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    btn.addEventListener('click', ()=>{
      if(flying) return;
      flying = true;
      flyStart = performance.now();
      document.body.classList.add('flying');
      fade.style.opacity = '1';
      btn.style.pointerEvents = 'none';
    });
  </script>
</body>
</html>
