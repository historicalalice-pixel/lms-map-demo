<!doctype html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LMS — Початок</title>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@300;400;500;600&display=swap');

    *{box-sizing:border-box}
    html,body{height:100%;margin:0}
    body{overflow:hidden;background:#000;color:#f3eed7}

    #wrap{
      position:fixed; inset:0;
      background:
        radial-gradient(1200px 700px at 50% 45%, rgba(70,85,180,.22), rgba(10,10,18,.92) 60%, #000 100%);
    }
    canvas{display:block;width:100%;height:100%}

    .intro{
      position:fixed; inset:0;
      display:flex; flex-direction:column;
      align-items:center; justify-content:center;
      text-align:center;
      padding:6vw;
      z-index:2;
      pointer-events:none;
      transition: opacity 1.2s ease;
    }
    .intro::before{
      content:"";
      position:absolute;
      width:min(980px,92vw);
      height:min(520px,60vh);
      border-radius:999px;
      background: radial-gradient(closest-side, rgba(0,0,0,.58), rgba(0,0,0,0));
      z-index:-1;
    }

    h1{
      margin:0 0 1.1rem;
      font-family:"Cormorant Garamond", serif;
      font-weight:500;
      font-size:clamp(3.0rem, 7.6vw, 6.8rem);
      line-height:.92;
      letter-spacing:-0.01em;
      color:rgba(243,238,215,.96);
      text-shadow: 0 24px 80px rgba(0,0,0,.55);
    }
    .subtitle{
      margin:0 0 2.6rem;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-size:clamp(1.05rem,2.2vw,1.5rem);
      opacity:.86;
      line-height:1.55;
      max-width:820px;
    }

    #startBtn{
      pointer-events:auto;
      padding:1rem 3.5rem;
      font-size:.95rem;
      letter-spacing:.32em;
      text-transform:uppercase;
      background:transparent;
      border:1.5px solid rgba(243,238,215,.55);
      color:#f3eed7;
      cursor:pointer;
      transition:transform .35s ease, background .35s ease, border-color .35s ease, opacity .35s ease;
    }
    #startBtn:hover{
      border-color: rgba(243,238,215,.92);
      background: rgba(243,238,215,.08);
      transform: translateY(-3px);
    }
    #startBtn:active{ transform: translateY(-1px) scale(.99); }

    #fade{
      position:fixed; inset:0;
      background:#000;
      opacity:0;
      transition: opacity 1.25s ease;
      pointer-events:none;
      z-index:3;
    }

    #vignette{
      position:fixed; inset:-2px;
      background: radial-gradient(1200px 800px at 50% 50%, transparent 42%, rgba(0,0,0,.68) 100%);
      pointer-events:none;
      z-index:1;
      opacity:.85;
    }

    body.flying .intro{opacity:0}
  </style>
</head>

<body>
  <div id="wrap"></div>
  <div id="vignette"></div>

  <div class="intro">
    <h1>Навчання — це подорож</h1>
    <p class="subtitle">Крізь час і знання</p>
    <button id="startBtn">ПОЧАТИ</button>
  </div>
  <div id="fade"></div>

  <!-- Three.js з CDN -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

    const wrap = document.getElementById("wrap");
    const btn  = document.getElementById("startBtn");
    const fade = document.getElementById("fade");

    // renderer
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    wrap.appendChild(renderer.domElement);

    // scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x000000, 12, 80);

    // camera
    const camera = new THREE.PerspectiveCamera(
      55,
      window.innerWidth / window.innerHeight,
      0.1,
      200
    );
    camera.position.set(0, 0, 18);

    // subtle light
    const light = new THREE.DirectionalLight(0xffffff, 0.25);
    light.position.set(1, 2, 3);
    scene.add(light);

    // ====== Years field (sprites/textures) ======
    // Робимо текстуру з текстом (рік) на canvas, потім Sprite
    function makeYearSprite(text) {
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d");

      const fontSize = 56;
      const pad = 28;

      ctx.font = `${fontSize}px "Cormorant Garamond"`;
      const w = Math.ceil(ctx.measureText(text).width) + pad * 2;
      const h = fontSize + pad * 2;

      c.width = w;
      c.height = h;

      ctx.clearRect(0,0,w,h);
      ctx.font = `${fontSize}px "Cormorant Garamond"`;
      ctx.fillStyle = "rgba(243,238,215,0.32)";
      ctx.shadowColor = "rgba(243,238,215,0.20)";
      ctx.shadowBlur = 14;
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      ctx.fillText(text, w/2, h/2);

      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;

      const mat = new THREE.SpriteMaterial({
        map: tex,
        transparent: true,
        depthWrite: false
      });

      const spr = new THREE.Sprite(mat);
      // базовий scale підлаштовується від "глибини" далі
      spr.scale.set(w/120, h/120, 1);
      return spr;
    }

    const group = new THREE.Group();
    scene.add(group);

    const now = new Date().getFullYear();
    const minY = 1700;
    const maxY = now + 40;

    const COUNT = 140;

    // safe-zone: виріз у центрі, щоб текст не забивало
    function inSafe(x,y){
      const rx = 6.0, ry = 2.6;
      const nx = x / rx;
      const ny = y / ry;
      return (nx*nx + ny*ny) < 1.0;
    }

    // розкидуємо точки у сфероподібному обʼємі перед камерою
    const nodes = [];
    for(let i=0;i<COUNT;i++){
      const year = Math.floor(minY + Math.random()*(maxY-minY+1));
      const spr = makeYearSprite(String(year));

      let x,y,z;
      let tries = 0;
      do{
        x = (Math.random()-0.5) * 26;     // ширина
        y = (Math.random()-0.5) * 14;     // висота
        z = -Math.random() * 90;          // вглиб (негатив)
        tries++;
        if(tries>80) break;
      }while(inSafe(x,y) && z > -45);

      spr.position.set(x,y,z);

      // рандомний розмір: ближче = більші
      const depth01 = THREE.MathUtils.clamp((-z) / 90, 0, 1);
      const s = 0.6 + (1.0 - depth01) * 1.2; // ближче більші
      spr.scale.multiplyScalar(s);

      // легка прозорість
      spr.material.opacity = 0.18 + (1.0 - depth01) * 0.22;

      group.add(spr);

      nodes.push({
        spr,
        base: spr.position.clone(),
        seed: Math.random()*1000
      });
    }

    // ====== Motion: camera look + subtle drift ======
    let mx = 0, my = 0;
    window.addEventListener("mousemove", (e)=>{
      mx = (e.clientX / window.innerWidth - 0.5);
      my = (e.clientY / window.innerHeight - 0.5);
    });

    function easeInOutCubic(t){
      return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2;
    }

    let flying = false;
    let flyStart = 0;
    const FLY_MS = 1650;

    // “референсний” проліт: камера летить вперед, а поле пролітає повз
    function animate(tms){
      const t = tms * 0.001;

      // камера “дивиться” за мишкою (важливо: це look, а не зсув обʼєктів)
      const targetLook = new THREE.Vector3(
        mx * 2.4,
        -my * 1.6,
        -16
      );

      // плавність
      camera.lookAt(
        THREE.MathUtils.lerp(camera.getWorldDirection(new THREE.Vector3()).x, targetLook.x, 0.06),
        THREE.MathUtils.lerp(camera.getWorldDirection(new THREE.Vector3()).y, targetLook.y, 0.06),
        targetLook.z
      );

      // легкий дрейф “поля” (але без відльоту)
      for(const n of nodes){
        const s = n.seed;
        const wobx = Math.sin(t*0.9 + s) * 0.10;
        const woby = Math.cos(t*0.8 + s*1.3) * 0.08;
        const wobz = Math.sin(t*0.7 + s*0.7) * 0.10;

        // пружина назад до base
        n.spr.position.x += (n.base.x + wobx - n.spr.position.x) * 0.02;
        n.spr.position.y += (n.base.y + woby - n.spr.position.y) * 0.02;
        n.spr.position.z += (n.base.z + wobz - n.spr.position.z) * 0.02;
      }

      if(flying){
        const dt = (performance.now() - flyStart) / FLY_MS;
        const tt = THREE.MathUtils.clamp(dt, 0, 1);
        const e = easeInOutCubic(tt);

        // камера реально летить вперед
        camera.position.z = THREE.MathUtils.lerp(18, 4, e);

        // і одночасно “пролітаємо” вглиб (зсув бази — виглядає як рух через поле)
        for(const n of nodes){
          n.base.z = n.base.z + (e * 0.9); // мікро, основне дає камера + перспектива
          // додатковий “push” на спрайти
          n.spr.position.z += e * 0.55;
          n.spr.material.opacity = Math.max(0, n.spr.material.opacity - e*0.65);
        }

        if(tt > 0.72){
          fade.style.opacity = String((tt - 0.72) / 0.28);
        }

        if(tt >= 1){
          location.href = "./main.html#overview";
          return;
        }
      }

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    requestAnimationFrame(animate);

    btn.addEventListener("click", ()=>{
      if(flying) return;
      flying = true;
      flyStart = performance.now();
      document.body.classList.add("flying");
      btn.disabled = true;
    });

    window.addEventListener("resize", ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });
  </script>
</body>
</html>
