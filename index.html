<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>LMS — Intro</title>

<style>
  @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;500;600&family=Inter:wght@300;400;500&display=swap');
  *{box-sizing:border-box}
  html,body{margin:0;height:100%;background:#05070d;color:#e8eefc;overflow:hidden}

  #intro{
    position:fixed; inset:0;
    background:
      radial-gradient(1200px 700px at 50% 40%, rgba(106,167,255,.12), transparent 55%),
      radial-gradient(900px 650px at 70% 70%, rgba(120,255,204,.06), transparent 55%),
      #05070d;
    display:flex; align-items:center; justify-content:center;
    z-index:10;
    transition: opacity 1.0s ease;
  }

  #stage{
    position:absolute; inset:0;
    perspective: 980px;
    perspective-origin: 50% 50%;
    transform-style: preserve-3d;
    overflow:hidden;
    pointer-events:none;
    contain: layout paint;
  }
  #cloud{
    position:absolute; inset:0;
    transform-style: preserve-3d;
    pointer-events:none;
    transform: translateZ(0);
    will-change: transform;
  }

  .intro-content{
    position:relative; z-index:3;
    text-align:center;
    width:min(980px,92vw);
    padding:24px;
    pointer-events:none;
    transition: opacity .65s ease, transform .65s ease, filter .65s ease;
  }

  .intro-content h1{
    font-family:"Cormorant Garamond", serif;
    font-weight:500;
    margin:0 0 14px;
    letter-spacing:.01em;
    font-size:clamp(46px,6.2vw,92px);
    line-height:1.02;
  }
  .intro-content p{
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    margin:0 0 30px;
    opacity:.72;
    line-height:1.65;
    font-size:clamp(13px,1.45vw,16px);
  }

  #enterBtn{
    pointer-events:auto;
    opacity:0;
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    font-weight:400;
    padding:12px 30px;
    background:transparent;
    border:1px solid rgba(255,255,255,.35);
    color:#e8eefc;
    letter-spacing:.18em;
    text-transform:uppercase;
    cursor:pointer;
    transition:opacity 1.2s ease,border-color .3s ease,transform .25s ease;
    user-select:none;
  }
  #enterBtn:hover{border-color:#fff;transform:translateY(-1px)}

  .year{
    position:absolute; left:0; top:0;
    transform-style:preserve-3d;
    will-change: transform, opacity;
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    letter-spacing:.12em;
    color: rgba(232,238,252,.95);
    white-space:nowrap;
    user-select:none;
    pointer-events:none;
    text-shadow: 0 0 14px rgba(0,0,0,.55);
  }

  /* During vortex: cut heavy effects */
  .vortex .year{
    text-shadow:none !important;
    filter:none !important;
  }

  /* Fade center content at vortex start (like reference) */
  .vortexing .intro-content{
    opacity:0;
    transform: translateY(-10px) scale(0.99);
    filter: blur(1px);
  }

  /* Fade overlay between scenes */
  #fadeOverlay{
    position:fixed; inset:0;
    background:#05070d;
    opacity:0;
    pointer-events:none;
    z-index:15;
    transition: opacity .6s ease;
  }

  /* MAP */
  #wrap{position:fixed;inset:0;opacity:0;pointer-events:none;transition:opacity 1s ease;z-index:1}
  #space{
    position:absolute; left:50%; top:50%;
    width:3000px; height:2000px;
    transform: translate(-50%,-50%) scale(1);
    background:
      radial-gradient(800px 400px at 30% 30%, rgba(106,167,255,.15), transparent 50%),
      radial-gradient(700px 500px at 70% 60%, rgba(120,255,204,.10), transparent 45%);
  }
  .node{
    position:absolute; left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:28px; height:28px; border-radius:50%;
    background:#6aa7ff;
    box-shadow:0 0 24px rgba(106,167,255,.6);
    cursor:pointer;
  }
  .label{
    position:absolute; top:36px; left:50%;
    transform:translateX(-50%);
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    font-size:12px; opacity:.85;
    white-space:nowrap;
  }

  /* DEMO */
  #scene{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#05070d;z-index:20}
  .card{
    max-width:720px;
    padding:28px;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.15);
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
    text-align:center;
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
  }
  .close-btn{
    margin-top:24px;
    padding:10px 22px;
    background:transparent;
    border:1px solid rgba(255,255,255,.35);
    color:#e8eefc;
    cursor:pointer;
    letter-spacing:.06em;
    user-select:none;
  }
  .hint{position:fixed;left:16px;bottom:16px;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif;font-size:12px;opacity:.6;z-index:5;user-select:none}
</style>
</head>

<body>
<div id="intro">
  <div id="stage"><div id="cloud"></div></div>
  <div class="intro-content" id="center">
    <h1>Навчання — це подорож</h1>
    <p>Перед тобою історія курсу.<br>Це лише вступ. Далі — глибше.</p>
    <button id="enterBtn">ENTER</button>
  </div>
</div>

<div id="fadeOverlay"></div>

<div id="wrap">
  <div id="space">
    <div class="node" id="demoNode"><div class="label">Демо-урок</div></div>
  </div>
</div>

<div id="scene">
  <div class="card">
    <h2>Демо-урок</h2>
    <p>Це приклад формату навчання.<br>Повний шлях відкривається після входу.</p>
    <button class="close-btn" id="closeScene">Повернутись</button>
  </div>
</div>

<div class="hint">ENTER → “занурення” → карта · На карті: перетягуй · Коліщатко — zoom</div>

<script>
/* ===== Years (4-digit only) ===== */
function makeYears(start,end){ const out=[]; for(let y=start;y<=end;y++) out.push(String(y)); return out; }
const YEARS_ALL = makeYears(1800, 2024);
const LIMIT = 170;
const YEARS = YEARS_ALL.slice(0, LIMIT);

/* ===== Layout tuning ===== */
const ORBIT_COUNT   = 56;
const SAFE_RADIUS_K = 0.23;
const ORBIT_RADIUS_K= 0.36;
const FOG_RADIUS_K  = 0.52;
const SPEED         = 0.050;

/* ===== Vortex = like 100lostspecies: tunnel + fly PAST camera ===== */
const VORTEX_MS        = 2800;   // longer = more “cinema”
const VORTEX_TWIST     = 18.0;   // spiral turns
const CAMERA_PUSH      = 1400;   // stronger forward camera
const TUNNEL_TIGHTEN   = 0.22;   // ring compress a bit (tunnel)
const PASS_Z           = 2200;   // how far they fly past camera
const NEAR_FADE_START  = 220;    // when close to camera start fading
const NEAR_FADE_RANGE  = 420;    // fade out fully within this distance

/* ===== Performance ===== */
const VORTEX_ACTIVE_RATIO = 0.60; // more immersion; reduce if FPS drops

const cloud = document.getElementById('cloud');
const stage = document.getElementById('stage');
const centerEl = document.getElementById('center');
const enterBtn = document.getElementById('enterBtn');
const intro = document.getElementById('intro');
const wrap = document.getElementById('wrap');
const fadeOverlay = document.getElementById('fadeOverlay');

function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }
function smoothstep(a,b,x){
  const t = clamp((x-a)/(b-a), 0, 1);
  return t*t*(3-2*t);
}
function easeInOutCubic(x){ return x<0.5 ? 4*x*x*x : 1-Math.pow(-2*x+2,3)/2; }

let vortex=false, vortexStart=0;
let rot=0;

setTimeout(()=>{ enterBtn.style.opacity='1'; enterBtn.style.pointerEvents='auto'; }, 2000);

enterBtn.addEventListener('click', ()=>{
  if(vortex) return;
  vortex=true;
  vortexStart=performance.now();

  stage.classList.add('vortex');
  intro.classList.add('vortexing');   // fade title like reference
  enterBtn.style.pointerEvents='none';

  // start darkening a bit later, like “cut to next scene”
  setTimeout(()=>{ fadeOverlay.style.opacity = '0.55'; }, 1350);
});

const items = YEARS.map((y,i)=>{
  const el=document.createElement('div');
  el.className='year';
  el.textContent=y;
  cloud.appendChild(el);

  const orbit = i < ORBIT_COUNT;
  const a0 = (i/(orbit?ORBIT_COUNT:YEARS.length))*Math.PI*2 + (Math.random()*0.12);

  return{
    el, orbit,
    a:a0,
    s:(0.40+Math.random()*0.70)*(Math.random()<0.5?-1:1),
    ph:Math.random()*Math.PI*2,
    z0: orbit ? (-80+Math.random()*180) : (-380+Math.random()*520),
    jx:(Math.random()*140-70),
    jy:(Math.random()*100-50),
    lastX:0,lastY:0,lastZ:0,lastScale:1,lastOp:0.1
  };
});

const vortexActiveCount = Math.floor(items.length * VORTEX_ACTIVE_RATIO);
const vortexActiveSet = new Set();
for(let i=0;i<vortexActiveCount;i++) vortexActiveSet.add(i);

let last=performance.now();
function tick(now){
  const dt=(now-last)/1000; last=now;

  const rect=centerEl.getBoundingClientRect();
  const cx=rect.left+rect.width/2;
  const cy=rect.top+rect.height/2;

  const minSide=Math.min(window.innerWidth, window.innerHeight);
  const SAFE = clamp(minSide*SAFE_RADIUS_K, 140, 240);
  const R_ORB = clamp(minSide*ORBIT_RADIUS_K, 280, 520);
  const R_FOG = clamp(minSide*FOG_RADIUS_K, 420, 820);

  const p  = vortex ? clamp((now - vortexStart)/VORTEX_MS, 0, 1) : 0;
  const pe = easeInOutCubic(p);

  // camera forward + slight zoom for immersion
  const cameraZ = vortex ? (pe * CAMERA_PUSH) : 0;
  const cloudZoom = vortex ? (1 + pe*0.28) : 1;
  cloud.style.transform = `translateZ(0) scale(${cloudZoom})`;

  rot += SPEED*dt*0.22;

  items.forEach((it,idx)=>{
    const vortexActive = !vortex || vortexActiveSet.has(idx);

    if(vortex && !vortexActive){
      it.el.style.transform =
        `translate3d(${it.lastX}px, ${it.lastY}px, ${it.lastZ}px) translate(-50%,-50%) scale(${it.lastScale})`;
      it.el.style.opacity = it.lastOp;
      return;
    }

    it.a += (SPEED*0.35)*dt*it.s;

    // spiral that ramps up strongly near the end
    const twist = vortex ? (pe * VORTEX_TWIST) : 0;
    const ramp = vortex ? smoothstep(0.15, 0.95, pe) : 0;
    const a = it.a + rot + twist * ramp * (0.35 + idx * 0.014);

    let r = it.orbit ? R_ORB : R_FOG;

    const breathe = Math.sin(now*0.00042 + it.ph) * (it.orbit ? 10 : 18);
    let x = Math.cos(a) * (r + breathe);
    let y = Math.sin(a) * (r + breathe) * 0.70;

    if(!it.orbit){
      x += Math.sin(now*0.00017 + it.ph) * 30 + it.jx*0.10;
      y += Math.cos(now*0.00015 + it.ph) * 20 + it.jy*0.10;
    }

    // keep center clean (even during vortex)
    const dist = Math.hypot(x,y);
    if(dist < SAFE){
      const k = SAFE / Math.max(1, dist);
      x *= k; y *= k;
    }

    // IMPORTANT: during vortex we DO NOT pull into center text.
    // We create a tunnel: slightly tighten ring, not collapse.
    if(vortex){
      const tighten = 1 - (pe * TUNNEL_TIGHTEN);
      x *= tighten;
      y *= tighten;
    }

    const zIdle = it.z0 + Math.sin(now*0.00031 + it.ph) * (it.orbit ? 18 : 34);

    // Fly past camera:
    // start behind, rush forward, go beyond, then fade out
    const zFly = vortex ? (pe * (PASS_Z + idx*2.2)) : 0;
    const z = zIdle + zFly - cameraZ;

    const zNorm = clamp((z + 420)/1500, 0, 1);

    // Do not change font-size during vortex (perf)
    if(!vortex){
      const font = it.orbit ? (13 + zNorm*4) : (10 + zNorm*2);
      it.el.style.fontSize = font.toFixed(1)+'px';
      it.el.style.textShadow = it.orbit
        ? '0 0 26px rgba(106,167,255,.20), 0 0 16px rgba(0,0,0,.55)'
        : '0 0 14px rgba(0,0,0,.55)';
      it.el.style.filter = 'none';
    }

    // As they approach camera, they should feel bigger
    const scaleBase = it.orbit ? (1.00 + zNorm*0.70) : (0.78 + zNorm*0.52);
    const nearBoost = vortex ? (1 + smoothstep(0.55, 0.95, pe) * 0.35) : 1;
    const scale = scaleBase * nearBoost;

    // opacity with "near fade" when too close to camera (so they pass by)
    const baseOp = it.orbit
      ? clamp(0.30 + zNorm*0.55, 0.18, 0.88)
      : clamp(0.04 + zNorm*0.24, 0.02, 0.32);

    let op = baseOp;

    if(vortex){
      // fade when z becomes very close/positive (camera plane)
      const t = clamp((z - NEAR_FADE_START)/NEAR_FADE_RANGE, 0, 1);
      op *= (1 - t);
    }

    const tx = cx + x;
    const ty = cy + y;

    it.el.style.opacity = op.toFixed(3);
    it.el.style.transform =
      `translate3d(${tx}px, ${ty}px, ${z}px) translate(-50%,-50%) scale(${scale})`;

    it.lastX = tx; it.lastY = ty; it.lastZ = z;
    it.lastScale = scale; it.lastOp = op.toFixed(3);
  });

  if(vortex && p>=1){
    // finalize transition
    stage.classList.remove('vortex');
    fadeOverlay.style.opacity = '1';

    setTimeout(()=>{
      intro.style.opacity='0';
      setTimeout(()=>{
        intro.style.display='none';
        wrap.style.opacity='1';
        wrap.style.pointerEvents='auto';
        fadeOverlay.style.opacity = '0'; // reveal map
      }, 420);
    }, 60);

    vortex=false;
    return;
  }

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* MAP pan/zoom + demo */
const space=document.getElementById('space');
let scale=1, mx=0, my=0, drag=false, sx=0, sy=0;
function apply(){ space.style.transform=`translate(${mx}px, ${my}px) scale(${scale})`; }
wrap.addEventListener('mousedown', e=>{ drag=true; sx=e.clientX-mx; sy=e.clientY-my; });
window.addEventListener('mouseup', ()=>drag=false);
window.addEventListener('mousemove', e=>{ if(!drag) return; mx=e.clientX-sx; my=e.clientY-sy; apply(); });
wrap.addEventListener('wheel', e=>{
  e.preventDefault();
  scale *= e.deltaY>0 ? 0.9 : 1.1;
  scale = Math.max(0.4, Math.min(2.5, scale));
  apply();
},{passive:false});

const scene=document.getElementById('scene');
document.getElementById('demoNode').onclick=()=>scene.style.display='flex';
document.getElementById('closeScene').onclick=()=>scene.style.display='none';
</script>
</body>
</html>
